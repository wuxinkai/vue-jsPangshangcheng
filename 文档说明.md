# 初始化

全局安装 vue-cli，在终端里输入

```
npm install vue-cli -g
```

用 webpack 初始化

```
  vue init webpack
```

![avatar](\clipboard.png)

# 安装 Vant 轻量、可靠的移动端 Vue 组件库

## 全局加载 vant

```
npm install vant -S
```

在 main.js 中全局引入插件

```
import vant from 'vant'
import 'vant/lib/index.css'
Vue.use(vant)
```

## 局部加载 vant 的某些组件

1. 加载插件

```
npm install babel-plugin-import -D
```

2. 在.babelrc 中设置,局部引入

```
 "plugins": [
    "transform-vue-jsx",
    "transform-runtime",
    ["import", {
      "libraryName": "vant",
      "styleLibraryName": "true"
    }]
  ]
```

3. 按需使用 Vant 组件

```
import { Button } from 'vant'
Vue.use(Button)
```

# 移动端屏幕适配基础

- index 页面内容

```
//得到手机屏幕的宽度
let htmlWidth = document.documentElement.clientWidth || document.body.clientWidth;

//设置最大宽度
if(htmlWidth>750){htmlWidth=750}

//得到html的Dom元素
let htmlDom = document.getElementsByTagName('html')[0];

//设置根元素字体大小
//iphone5  320/20 =16
htmlDom.style.fontSize= htmlWidth/20 + 'px';
```

- 设置标头

```
<meta name="viewport" content="width=device-width,initial-scale=1.0 ,user-scalable=no ">
```

# 图片懒加载

```
import { Swipe , SwipeItem , Lazyload  } from 'vant'
Vue.use(Swipe).use(SwipeItem).use(Lazyload)

<div class="swiper-area">
    <van-swipe :autoplay="1000">
        <van-swipe-item v-for="(banner,index) in bannerPicArray" :key="index">
            <img v-lazy="banner.imageUrl" width="100%"/>
        </van-swipe-item>
    </van-swipe>
</div>
```

# easyMock 和 Axios 的使用

### 下载

```
npm install --save axios
```

在页面引入

```
import axios from 'axios'
```

页面 get 请求

```
axios({
    url: 'https://www.easy-mock.com/mock/5c7006fba0b64b7d17824c17/SmileVue/index',
    method: 'get',
  }).then(response => {
    this.category=response.data.data.category;
  }).catch((error) => {})
}
```

# 商品推荐 vue-awesome-swiper 横向滑动效果

```
 npm install vue-awesome-swiper --save
```

在 main.js 全局引入

```
import Vue from 'vue'
import VueAwesomeSwiper from 'vue-awesome-swiper'
import 'swiper/dist/css/swiper.css'
Vue.use(VueAwesomeSwiper, /* { default global options } */)
```

局部引用 在当前页面 ShoppingMall
http://idangero.us/swiper/api/

```
import 'swiper/dist/css/swiper.css'
import { swiper, swiperSlide } from 'vue-awesome-swiper'
export default {
  data(){
    return:{
     swiperOption: {
        loop:true, //无线循环 滚动
        slidesPerView: 3, //页面视觉呈现多少个
        direction: 'vertical', //设置竖排显示
        // slidesPerView: 'auto', // 设置同屏显示的数量，默认为1，这里使用auto是随意的意思。
        // freeMode: true, //普通模式：slide滑动时只滑动一格，并自动贴合wrapper，设置为true则变为free模式，slide会根据惯性滑动可能不止一格且不会贴合。
        // mousewheel: true, //开启鼠标滚轮控制Swiper切换。可设置鼠标选项，或true使用默认值。
        pagination: {
          el: '.swiper-pagination',
          clickable: true
        }
      }
    }
  }
  components: {
    swiper,
    swiperSlide
  }
}
```

swiper 的 html 内容

```
<swiper :options="swiperOption">
  <swiper-slide v-for=" (item ,index) in recommendGoods" :key="index">
    <div class="recommend-item">
      <img :src="item.image" width="80%" />
      <div>{{item.goodsName}}</div>
      <div>￥{{item.price}} (￥{{item.mallPrice}})</div>
    </div>
  </swiper-slide>
</swiper>
```

# 用 watch 方法解决 父页面数据请求延时报错问题

父页面

```
<floor-component :floorData="floor1"></floor-component>
```

子页面

```
 export default {
      //接收 楼层数据
        props:['floorData'],
        data() {
            return {
                floorData0:{},
                floorData1:{},
                floorData2:{}
            }
        },
        created(){
            //这里写得不到数据，应为数据是延迟返回的
        },
        watch:{// 监视的数据floorData  只要发生变化
            floorData:function(val){
                console.log(this.floorData)
                this.floorData0=this.floorData[0]
                this.floorData1=this.floorData[1]
                this.floorData2=this.floorData[2]
            }
        }
    }
```

# 相同内容封装成组件

```
floorComponent.vue中
```

# Filter 在实战中的使用

- 父页面

```
 import { toMoney } from '@/filter/moneyFilter.js'

 <div>￥{{item.price | moneyFilter}} (￥{{item.mallPrice|moneyFilter}})</div>

 filters: {
    //moneyFilter自己写一个方法
    moneyFilter(money) {
      return toMoney(money)
    }
  },
```

- moneyFilter.js 页面

```
export function toMoney(money = 0){
  return money.toFixed(2)
}

```

# 编写后台服务接口配置文件

```
const BASEURL = "https://www.easy-mock.com/mock/5c7006fba0b64b7d17824c17/SmileVue/"
const URL = {
    getShoppingMallInfo:BASEURL+'index',
    getGoodsInfo:BASEURL+'getGoodsInfo'
}
module.exports = URL
```

应用

```
import url from '@/serviceAPI.config.js'
axios({
    url: url.getShoppingMallInfo,
    method: 'get',
})
```

# 遇到的问题

1. 屏幕适配，和 meta 适配
2. 轮播图清楚左侧有空隙，图片懒加载
3. Chrome 调试技巧 模拟慢速 3G 网络
4. css3 横向布局
5. swiper 的学习 ,添加分页器 ,竖屏切换效果,区域滚动效果，分页自由选择，无线循环滚动
6. （不规则的布局）页面加载子组件请求父页面内容，axios 还没请求到，子页面报错，用 watch 方法解决，
7. （不规则的布局） 相同内容封装成组件。
8. 循环传给子组件值
9. 编写后台服务接口配置文件
10. export 页面通讯的传递参数

# 后台

安装 Koa2 到项目中来 ，在 service 文件夹下

```
npm install --save koa
```

index.js 内容

```
const Koa = require('koa')
const app = new Koa()
app.use(async(ctx)=>{
    ctx.body = '<h1>hello Koa2</h1>'
})
app.listen(3000,()=>{
    console.log('[Server] starting at port 3000')
})
```

启动

```
node index.js
```

# 数据库的操作流程

## 安装 MongoDB 数据库

```
mongod:在命令中直接输入mongod
```

## Mongoose 的安装

```
npm install mongoose --save
```

在 /service/database/init.js 的内容

```
const mongoose = require('mongoose')
const db = "mongodb://localhost/smile-db"
exports.connect = ()=>{
    //连接数据库
    mongoose.connect(db)
    let maxConnectTimes = 0
    return  new Promise((resolve,reject)=>{
    //把所有连接放到这里
        //增加数据库监听事件
        mongoose.connection.on('disconnected',()=>{
            console.log('***********数据库断开***********')
            if(maxConnectTimes<3){
                maxConnectTimes++
                mongoose.connect(db)
            }else{
                reject()
                throw new Error('数据库出现问题，程序无法搞定，请人为修理......')
            }
        })
        mongoose.connection.on('error',err=>{
            console.log('***********数据库错误***********')
            if(maxConnectTimes<3){
                maxConnectTimes++
                mongoose.connect(db)
            }else{
                reject(err)
                throw new Error('数据库出现问题，程序无法搞定，请人为修理......')
            }
        })
        //链接打开的时
        mongoose.connection.once('open',()=>{
            console.log('MongoDB connected successfully')
            resolve()
        })
    })
}
```

## Schema

- schema ：用来定义表的模版，实现和 MongoDB 数据库的映射。用来实现每个字段的类型，长度，映射的字段，不具备表的操作能力。
- model ：具备某张表操作能力的一个集合，是 mongoose 的核心能力。我们说的模型就是这个 Mondel。
- entity ：类似记录，由 Model 创建的实体，也具有影响数据库的操作能力。

### 数据类型

- String ：字符串类型
- Number ：数字类型
- Date ： 日期类型
- Boolean： 布尔类型
- Buffer ： NodeJS buffer 类型
- ObjectID ： 主键,一种特殊而且非常重要的类型
- Mixed ：混合类型
- Array ：集合类型

### User.js 的名字要和表的名字一样

```
const mongoose = require('mongoose')    //引入Mongoose
const Schema = mongoose.Schema          //声明Schema
let ObjectId = Schema.Types.ObjectId    //声明Object类型

//创建我们的用户Schema
const userSchema = new Schema({
    UserId:ObjectId,
    userName:{unique:true,type:String},
    password:String,
    createAt:{type:Date,default:Date.now()},
    lastLoginAt:{type:Date,default:Date.now()}
})

// 发布模型, User对应的是数据库里的users 这个表名字
// 大写的U变成了小写u，h后面又加了个s
mongoose.model('User', UserShema)
```

![avatar](\static\images\3.png)

## 解决 数据库名字和 我们程序里名字不一样的办法

![avatar](\static\images\4.png)

## 载入 Schema 和插入查出数据

- glob：node 的 glob 模块允许你使用 \* 等符号，来写一个 glob 规则，像在 shell 里一样，获取匹配对应规则文件。
- resolve: 将一系列路径或路径段解析为绝对路径。

```
npm install glob --save
```

在 init.js 引入

```
const glob = require('glob')
const {resolve} = require('path')

//把schema文件夹下所有的文件都引入的这里面， 利用通配符
exports.initSchemas = () =>{
    glob.sync(resolve(__dirname,'./schema/','**/*.js')).forEach(require)
}
```

## 操作数据库 在 index.js 中

```
const mongoose = require('mongoose')
const {connect , initSchemas} = require('./database/init.js')

//插入username
;(async () =>{
    await connect()
    initSchemas()
    const User = mongoose.model('User')
    let oneUser = new User({userName:'jspang',password:'123456'})
    oneUser.save().then(()=>{
        console.log('插入成功')
    })
})()
```

![avatar](\static\images\mongose.png)

# 加密

- 加密处理:比如我们使用的 MD5 加密或者 hash256 加密算法，暴力破解或者字典破解（彩虹表）都可以破解
- 加盐处理 :向我们的密码中加其他东西，

### bcrypt 的加密工具

利用淘宝源进行安装

```
npm install --save bcrypt --registry=https://registry.npm.taobao.org
```

在 schema\User.js 引入 bcrypt 的内容

```
const bcrypt = require('bcrypt')
let SALT_WORK_FACTOR =10 //加盐

UserShema.pre('save', function(next){
  //let user = this
  console.log(this)
  bcrypt.genSalt( SALT_WORK_FACTOR,(err,salt)=>{
      if(err) return next(err)
      bcrypt.hash(this.password,salt, (err,hash)=>{
          if(err) return next(err)
          this.password = hash
          next()
      })
  })
})
```

![avatar](\static\images\2.png)

# Koa2 的用户操作的路由模块化

```
npm install koa-router --save


const Router = require ('koa-router')
let router = new Router()
router.get('/',async(ctx)=>{
    ctx.body="这是用户操作首页"
})
router.post('/register',async(ctx)=>{
    console.log(ctx)
    console.log(ctx.request.body)
    //把结果返回给前端
    ctx.body= ctx.request.body
})
module.exports=router;
```

在 index.js 中引入

```
//路由
const Router = require('koa-router')
let user = require('./appApi/user')
//装载路由
let router = new Router();
router.use('/user', user.routes())
//加载路由中间件
app.use(router.routes())
app.use(router.allowedMethods()) //把所有的方法都装载进来
```

# 打通注册用户的前后端通讯

- 安装 koa-bodyparser 中间件 将字符串转化为对象
- 在 service/index.js 文件中注册和引入中间件

```
npm install --save koa-bodyparser

const bodyParser = require('koa-bodyparser')
app.use(bodyParser());
```

register.vue 头部引入 axios

```
import axios from 'axios'
import url from '@/serviceAPI.config.js'

//请求方法
axiosRegisterUser(){
        axios({
        url: url.registerUser,
        method: 'post',
        data:{
            username:this.username,
            password:this.password
        }
    })
    .then(response => {
        console.log(response)
    })
    .catch((error) => {
        console.log(error)
    })
}
```

修改 serviceAPI.config.js

```
const LOCALURL = "http://localhost:3000/"

const URL = {
    getShoppingMallInfo:BASEURL+'index',
    getGoodsInfo:BASEURL+'getGoodsInfo',
    registerUser:LOCALURL+'user/register',   //用户注册接口
}
module.exports = URL
```

# 解决跨域

安装 koa2-cors 中间件 要在 service/index.js

```
const cors = require('koa2-cors')
app.use(cors())
```

# 用户内容写入数据库

在 service/appApi/user.js 下引入 mongose

```
const mongoose = require('mongoose')

router.post('/register', async (ctx) => {

  //取得Model User是E:\A学习盘database\schema\User.js 文件夹的名字
  const User = mongoose.model('User')

  //把从前端接收的POST数据封装成一个新的user对象
  let newUser = new User(ctx.request.body)

  //用mongoose的save方法直接存储，然后判断是否成功，返回前端相应的结果
  await newUser.save().then(() => {
    //成功返回code=200，并返回成功信息
    ctx.body = {
      code: 200,
      message: '注册成功'
    }
  }).catch(error => {
    //失败返回code=500，并返回错误信息
    ctx.body = {
      code: 500,
      message: error
    }
  })
})
```

前端判断

```
 axiosRegisterUser() {
      axios({
        url: url.registerUser,
        method: 'post',
        data: {
          userName: this.username,
          password: this.password
        }
      })
        .then(response => { //成功判断
          if(response.data.code == 200){
            Toast.success(response.data.message)
          }else{
            console.log(response.data.message) //注册失败
            Toast.fail('注册失败')
          }
        })
        .catch((error) => { //是吧
          console.log(error)
        })
    }
```

# 注册防重复提交 在前台做的

绑定 loadding 属性。
<van-button type="primary" @click="axiosRegisterUser" :loading="openLoading" size="large">马上注册</van-button>
在代码中 点击按钮开始 this.openLoading =true,
其他地方都关闭 this.openLoading =false,（报错的地方，）

# 前端验证，

1. input 空值不能提交
2. 前端和后台都需要数据验证
   ![avatar](\static\images\5.png)

# 登录

## Shema 中的比对实例方法,

在 database\schema\User.js 里写 密码比对的方法

```
//密码比对的方法  methods是实例方法 必须用new 才能用
UserSchema.methods = {
  //_password 数据库密码 , password 当前密码
  comparePassword:(_password,password)=>{
      return new Promise((resolve,reject)=>{
          bcrypt.compare(_password,password,(err,isMatch)=>{
              if(!err) resolve(isMatch)
              else reject(err)
          })
      })
  }
}
```

## 进入 service/appApi/user.js，增加一个 login 路由

```
router.post('/login', async (ctx) => {
  //得到前端传递过来的数据
  let loginUser = ctx.request.body //前端传过来的对象
  console.log(loginUser)
  let userName = loginUser.userName
  let password = loginUser.password
  //引入User的model
  const User = mongoose.model('User')
  //查找名字
  await User.findOne({
    userName: userName
  }).exec().then(async (result) => {
    //判断用户名是否存在，如果存在就再比对密码
    if (result) {
      let newUser = new User() //因为是实例方法，所以要new出对象，才能调用
      await newUser.comparePassword(password, result.password) //comparePassword 再\database\schema\User.js 文件里的方法
        .then((isMatch) => {
          //返回比对结果
          ctx.body = {
            code: 200,
            message: isMatch
          }
        }).catch(error => {
          //出现异常，返回异常
          console.log(error)
          ctx.body = {
            code: 500,
            message: error
          }
        })
    } else {

    }
  }).catch(error => {
    console.log(error)
    ctx.body = {
      code: 500,
      message: error
    }
  })
})
```

## 前台配置接口

1.在 src/serviceAPI.config.js 下加入接口代码

```
const BASEURL = "https://www.easy-mock.com/mock/5c7006fba0b64b7d17824c17/SmileVue/"
const LOCALURL = "http://localhost:3000/"
const URL = {
    getShoppingMallInfo:BASEURL+'index',
  getGoodsInfo: BASEURL + 'getGoodsInfo',
  registerUser:LOCALURL+'user/register',   //用户注册接口
  login:LOCALURL+'user/login',   //用户登录接口
}
module.exports = URL
```

# 判断是否登录

利用 Promise 和 localStorage 存储

```
  axiosLoginUser() {
      //先把按钮进行loading状态，防止重复提交
      this.openLoading = true
      axios({
        url: url.login,
        method: 'post',
        data: {
          userName: this.username,
          password: this.password
        }
      })
        .then(response => {
          if (response.data.code == 200 && response.data.message) {
            //等待数据
            new Promise((resolve, reject) => {
              //存储
              localStorage.userInfo = { userName: this.username }
              //等半秒向下执行
              setTimeout(() => {
                resolve()
              }, 500)
            }).then(response => {
              //本地存储完了再页面跳转
              Toast.success('登录成功')
              this.$router.push('/')
            }).chart(error => {
              Toast.fail('登录失败')
              console.log(error);
            })
          } else {
            Toast.fail('登录失败')
            this.openLoading = false
          }
        })
        .catch((error) => {
          console.log(error)
          Toast.fail('登录失败')
          this.openLoading = false
        })
    },
```

读取是否登录

```
created(){
    if(localStorage.userInfo){
        Toast.success('您已经登录')
        this.$router.push('/')
    }
},

```

# 数据提纯

在 service 文件夹下，新建一个 fsJson.js 的文件使用 node 的 fs 模块

```
fs = require('fs')
fs.readFile('data_json/goods.json', 'utf8', function (err, data) {
  //转成对象格式
  let newData = JSON.parse(data)
  // 提取后的数组
  let i = 0 //看提纯后的数据有多少条
  let pushData = [] //存储到新的数组

  //map新数组
  newData.RECORDS.map(function (value, index) {
    //"IMAGE1" 不等于 null,时候才是有用的数据
    if (value.IMAGE1 != null) {
      i++
      console.log(value.NAME) //打印名字
      pushData.push(value)
    }
  })

  // 写到新的文件中
  fs.writeFile('./data_json/newGoods.json', JSON.stringify(pushData), function (err) {
    if (err) console.log('写文件操作失败');
    else console.log('写文件操作成功');
  });

})


//在下面路径执行 node fxjson.js
// vue-jsPangshangcheng\service> node fsJson.js

```

# 批量插入商品详情数据到 MongoDB 中

建立 servic/database/schema/Goods.js 文件

```
const mongoose = require('mongoose')    //引入Mongoose
const Schema = mongoose.Schema          //声明Schema
let ObjectId = Schema.Types.ObjectId    //声明Object类型
const goodsSchema = new Schema({
    ID:{unique:true,type:String},
    GOODS_SERIAL_NUMBER:String,
    SHOP_ID:String,
    SUB_ID:String,
    GOOD_TYPE:Number,
    STATE:Number,
    NAME:String,
    ORI_PRICE:Number,
    PRESENT_PRICE:Number,
    AMOUNT:Number,
    DETAIL:String,
    BRIEF:String,
    SALES_COUNT:Number,
    IMAGE1:String,
    IMAGE2:String,
    IMAGE3:String,
    IMAGE4:String,
    IMAGE5:String,
    ORIGIN_PLACE:String,
    GOOD_SCENT:String,
    CREATE_TIME:String,
    UPDATE_TIME:String,
    IS_RECOMMEND:Number,
    PICTURE_COMPERSS_PATH:String
},{
    collections:'Goods'
})
mongoose.model('Goods',goodsSchema)
```

新建一个 service/appApi/goods.js

```
const Koa = require('koa')
const app = new Koa()
const Router = require ('koa-router')
let router = new Router()
const mongoose = require('mongoose')
const fs = require('fs')
router.get('/insertAllGoodsInfo',async(ctx)=>{
     fs.readFile('./goods.json','utf8',(err,data)=>{
        data=JSON.parse(data)
        let saveCount=0
        const Goods = mongoose.model('Goods')
        data.map((value,index)=>{
            console.log(value)
            let newGoods = new Goods(value)
            newGoods.save().then(()=>{
                saveCount++
                console.log('成功'+saveCount)
            }).catch(error=>{
                 console.log('失败：'+error)
            })
        })
    })
    ctx.body="开始导入数据"
})
module.exports=router;
```
.把路由加入到index.js里
```
let goods = require('./appApi/goods.js')
router.use('/goods',goods.routes())
```


1. 安装 koa 在 service\index.js 写 koa 的配置
2. 安装 mongoDB 在/service/database/init.js 写 mongoDB 的配置
3. 下载界面化工具 robo 3t 的下载
4. Schema 字段格式配置 在 service\database\schema\User.js 写数据库字段格式配置
5. glob 在/service/database/init.js 读取 所有 schema 文件夹下的内容
6. 写入数据量内容 在 service\index.js 写入内容
7. 启动顺序，先启动数据库 cmd 后执行 mongod 再执行 node index.js
8. bcrypt 加盐加密处理
9. 用户操作路由模块 koa-router
10. 打通注册用户的前后端通讯 koa-bodyparser 将传入的对象转为字符串
11. koa 解决跨域安装 koa2-cors 中间件
12. 防重复提交
13. 登录效果，需要解密 bcrypt.compare
14. 前端交互效果和登录内容储存,登录一次只要没有退出就不让继续登录 localStorage
15. created 中验证 页面是否已经登录过如果登录，就让其跳到当前页
16. 数据提纯筛选数据
17. 计算当前有效文件
