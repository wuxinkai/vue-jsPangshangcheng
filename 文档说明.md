# 初始化

全局安装 vue-cli，在终端里输入

```
npm install vue-cli -g
```

用 webpack 初始化

```
  vue init webpack
```

![avatar](/clipboard.png)

# 安装 Vant 轻量、可靠的移动端 Vue 组件库

## 全局加载 vant

```
npm install vant -S
```

在 main.js 中全局引入插件

```
import vant from 'vant'
import 'vant/lib/index.css'
Vue.use(vant)
```

## npm 和 cnpm 不要混用，会报错

## 局部加载 vant 的某些组件

1. 加载插件

```
npm install babel-plugin-import -D
```

2. 在.babelrc 中设置,局部引入

```
 "plugins": [
    "transform-vue-jsx",
    "transform-runtime",
    ["import",{"libraryName":"vant","style":true}]
  ]
```

3. 按需使用 Vant 组件

```
import { Button } from 'vant'
Vue.use(Button)
```

# 移动端屏幕适配基础

- index 页面内容

```
//得到手机屏幕的宽度
let htmlWidth = document.documentElement.clientWidth || document.body.clientWidth;

//设置最大宽度
if(htmlWidth>750){htmlWidth=750}

//得到html的Dom元素
let htmlDom = document.getElementsByTagName('html')[0];

//设置根元素字体大小
//iphone5  320/20 =16
htmlDom.style.fontSize= htmlWidth/20 + 'px';
```

- 设置标头

```
<meta name="viewport" content="width=device-width,initial-scale=1.0 ,user-scalable=no ">
```

# Vant 布局讲解

直接在/scr/main.js 里引入 Row 和 Col 组件

```
import { Button, Row, Col } from 'vant'
Vue.use(Button).use(Row).use(Col)
```

在 pages\ShoppingMall.vue 页面中输入

```
<van-row>
  <van-col span="8">span: 8</van-col>
  <van-col span="8">span: 8</van-col>
  <van-col span="8">span: 8</van-col>
</van-row>
```

# 图片懒加载

在/scr/main.js 里引入 Row 和 Col 组件 Swipe , SwipeItem 加载轮播图 ，图片懒加载 Lazyload

```
import { Swipe , SwipeItem , Lazyload  } from 'vant'
Vue.use(Swipe).use(SwipeItem).use(Lazyload)
```

在 pages\ShoppingMall.vue 页面中输入

```
<div class="swiper-area">
    <van-swipe :autoplay="1000">
        <van-swipe-item v-for="(banner,index) in bannerPicArray" :key="index">
            <img v-lazy="banner.imageUrl" width="100%"/>
        </van-swipe-item>
    </van-swipe>
</div>
```

#data 里的数据

```
 bannerPicArray: [ //轮播图
    { imageUrl: require('&/images/banner1.jpg') },
    { imageUrl: require('&/images/banner2.jpg') },
    { imageUrl: require('&/images/banner3.jpg') },
    { imageUrl: require('&/images/banner4.jpg') },
  ],
```

#### 解决 bug 清楚浮动就解决左边空白问题

![avatar](/static/images/8.png)

```
.swiper-area {
  width: 20rem;
  clear: both;
}
```

# easyMock 和 Axios 的使用

### 下载

```
npm install --save axios
```

在页面引入

```
import axios from 'axios'
```

页面加载

```
  created() {
    axios({
      url: 'https://www.easy-mock.com/mock/5c7006fba0b64b7d17824c17/SmileVue/index',
      method: 'get',
    }).then(response => {
      this.category = response.data.data.category;
    }).catch((error) => { })
  },
```

绑定数据

```
 <div class="type-bar">
    <div v-for="(cate,index) in category" :key="index">
      <img v-lazy="cate.image" width="90%" />
      <span>{{cate.mallCategoryName}}</span>
    </div>
  </div>
```

flex 布局

```
 .type-bar{
      background-color: #fff;
      margin:0 .3rem .3rem .3rem;
      border-radius: .3rem;
      font-size:14px;
      display: flex;
      flex-direction:row;
      flex-wrap:nowrap;
  }
  .type-bar div{
      padding: .3rem;
      font-size: 12px;
      text-align: center;
  }
```

### 解决大小不统一的问题

![avatar](/static/images/9.png)

```
.type-bar div{
  flex:1;
}
```

# 商品推荐 vue-awesome-swiper 横向滑动效果

```
 npm install vue-awesome-swiper --save
```

在 main.js 全局引入

```
import Vue from 'vue'
import VueAwesomeSwiper from 'vue-awesome-swiper'
import 'swiper/dist/css/swiper.css'
Vue.use(VueAwesomeSwiper, /* { default global options } */)
```

局部引用 在当前页面 ShoppingMall
http://idangero.us/swiper/api/

```
import 'swiper/dist/css/swiper.css'
import { swiper, swiperSlide } from 'vue-awesome-swiper'
export default {
  data(){
    return:{
     swiperOption: {
        loop:true, //无线循环 滚动
        slidesPerView: 3, //页面视觉呈现多少个
        // direction: 'vertical', //设置竖排显示
        // slidesPerView: 'auto', // 设置同屏显示的数量，默认为1，这里使用auto是随意的意思。
        // freeMode: true, //普通模式：slide滑动时只滑动一格，并自动贴合wrapper，设置为true则变为free模式，slide会根据惯性滑动可能不止一格且不会贴合。
        // mousewheel: true, //开启鼠标滚轮控制Swiper切换。可设置鼠标选项，或true使用默认值。
        pagination: {
          el: '.swiper-pagination',
          clickable: true
        }
      }
    }
  }
  components: {
    swiper,
    swiperSlide
  }
}
```

swiper 的 html 内容

```
<swiper :options="swiperOption">
  <swiper-slide v-for=" (item ,index) in recommendGoods" :key="index">
    <div class="recommend-item">
      <img :src="item.image" width="80%" />
      <div>{{item.goodsName}}</div>
      <div>￥{{item.price}} (￥{{item.mallPrice}})</div>
    </div>
  </swiper-slide>
</swiper>
```

# 用 watch 方法解决 父页面数据请求延时报错问题

### 父页面 pages\ShoppingMall.vue

引入组件 和注册组件

```
import floorComponent from './../component/floorComponent'

 components: {
   floorComponent
 }
```

js 代码

```
 data() {
  return {
    floor1: [],
    floor2: [],
    floor3: [],
    floorName: {},
  },
  created() {
    axios({
      url: url.getShoppingMallInfo,
      method: 'get',
    }).then(response => {
      if (response.status == 200) {
        this.floor1 = response.data.data.floor1//楼层1数据
        this.floor2 = response.data.data.floor2//楼层2数据
        this.floor3 = response.data.data.floor3//楼层3数据
        this.floorName = response.data.data.floorName
      }
    }).catch((error) => { })
  },
```
html 代码
```
<floor-component :floorData="floor1" :floorTitle="floorName.floor1"></floor-component>
<floor-component :floorData="floor2" :floorTitle="floorName.floor2"></floor-component>
<floor-component :floorData="floor3" :floorTitle="floorName.floor3"></floor-component>
```

### 子页面 components\component\floorComponent.vue

```
 export default {
      //接收 楼层数据
        props:['floorData'],
        data() {
            return {
                floorData0:{},
                floorData1:{},
                floorData2:{}
            }
        },
        created(){
            //这里写得不到数据，应为数据是延迟返回的
        },
        watch:{// 监视的数据floorData  只要发生变化
            floorData:function(val){
                console.log(this.floorData)
                this.floorData0=this.floorData[0]
                this.floorData1=this.floorData[1]
                this.floorData2=this.floorData[2]
            }
        }
    }
```
html绑定数据
```
 <div>
    <div class="floor-title"> {{floorTitle}} </div>
    <div class="floor">
        <div class="floor-anomaly">
            <div class="floor-one"><img :src="floorData0.image" width="100%" /></div>
            <div>
                <div class="floor-two"><img :src="floorData1.image" width="100%" /></div>
                <div><img :src="floorData2.image" width="100%" /></div>
            </div>
        </div>
        <div class="floor-rule">
            <div v-for="(item ,index) in floorData.slice(3)" :key="index">
                <img :src="item.image" width="100%"/>
            </div>
        </div>
    </div>
</div>
```

## 将相同内容封装成组件


# Filter 在实战中的使用

- 父页面

```
 import { toMoney } from '@/filter/moneyFilter.js'

 <div>￥{{item.price | moneyFilter}} (￥{{item.mallPrice|moneyFilter}})</div>

 filters: {
    //moneyFilter自己写一个方法
    moneyFilter(money) {
      return toMoney(money)
    }
  },
```

- moneyFilter.js 页面

```
export function toMoney(money = 0){
  return money.toFixed(2)
}

```

# 编写后台服务接口配置文件

```
const BASEURL = "https://www.easy-mock.com/mock/5c7006fba0b64b7d17824c17/SmileVue/"
const URL = {
    getShoppingMallInfo:BASEURL+'index',
    getGoodsInfo:BASEURL+'getGoodsInfo'
}
module.exports = URL
```

应用

```
import url from '@/serviceAPI.config.js'
axios({
    url: url.getShoppingMallInfo,
    method: 'get',
})
```

# 遇到的问题

1. 屏幕适配，和 meta 适配
2. 轮播图清楚左侧有空隙，图片懒加载
3. Chrome 调试技巧 模拟慢速 3G 网络
4. css3 横向布局
5. swiper 的学习 ,添加分页器 ,竖屏切换效果,区域滚动效果，分页自由选择，无线循环滚动
6. （不规则的布局）页面加载子组件请求父页面内容，axios 还没请求到，子页面报错，用 watch 方法解决，
7. （不规则的布局） 相同内容封装成组件。
8. 循环传给子组件值
9. 编写后台服务接口配置文件
10. export 页面通讯的传递参数

# 后台

安装 Koa2 到项目中来 ，在 service 文件夹下

```
npm install --save koa
```
创建目录
```
mkdir service
cd service
```
使用npm init -y 生成并初始化package.json 文件。
```
npm init -y
```
index.js 内容

```
const Koa = require('koa')
const app = new Koa()
app.use(async(ctx)=>{
    ctx.body = '<h1>hello Koa2</h1>'
})
app.listen(3000,()=>{
    console.log('[Server] starting at port 3000')
})
```

启动

```
node index.js
```
http://localhost:3000

# 数据库的操作流程

## 安装 MongoDB 数据库

```
mongod:在命令中直接输入mongod
```

## Mongoose 的安装

```
npm install mongoose --save
```
## 在mac 下的启动
在 /Users/wuxinkai/Documents/mongodb/bin 执行
```
./mongod
```

n在 /service/database/init.js 的内容

```
const mongoose = require('mongoose')
const db = "mongodb://localhost/smile-db"
exports.connect = ()=>{
    //连接数据库
    mongoose.connect(db)
    let maxConnectTimes = 0
    return  new Promise((resolve,reject)=>{
    //把所有连接放到这里
        //增加数据库监听事件
        mongoose.connection.on('disconnected',()=>{
            console.log('***********数据库断开***********')
            if(maxConnectTimes<3){
                maxConnectTimes++
                mongoose.connect(db)
            }else{
                reject()
                throw new Error('数据库出现问题，程序无法搞定，请人为修理......')
            }
        })
        mongoose.connection.on('error',err=>{
            console.log('***********数据库错误***********')
            if(maxConnectTimes<3){
                maxConnectTimes++
                mongoose.connect(db)
            }else{
                reject(err)
                throw new Error('数据库出现问题，程序无法搞定，请人为修理......')
            }
        })
        //链接打开的时
        mongoose.connection.once('open',()=>{
            console.log('MongoDB connected successfully')
            resolve()
        })
    })
}
```
讲内容引入到/service/index.js里加入立即执行函数，在使用前记得用require进行引入 connect。
```
const {
  connect,
  initSchemas
} = require('./database/init.js')

//立即执行函数
(async () => {
  await connect()
  //写入数据库 读取schema文件夹下的所有文件
  initSchemas()

})()
```
再从新执行 node index.js

## Schema

- schema ：用来定义表的模版，实现和 MongoDB 数据库的映射。用来实现每个字段的类型，长度，映射的字段，不具备表的操作能力。
- model ：具备某张表操作能力的一个集合，是 mongoose 的核心能力。我们说的模型就是这个 Mondel。
- entity ：类似记录，由 Model 创建的实体，也具有影响数据库的操作能力。

### 数据类型

- String ：字符串类型
- Number ：数字类型
- Date ： 日期类型
- Boolean： 布尔类型
- Buffer ： NodeJS buffer 类型
- ObjectID ： 主键,一种特殊而且非常重要的类型
- Mixed ：混合类型
- Array ：集合类型

### User.js 的名字要和表的名字一样
在service/database/schema/User.js 创建
```
const mongoose = require('mongoose')    //引入Mongoose
const Schema = mongoose.Schema          //声明Schema
let ObjectId = Schema.Types.ObjectId    //声明Object类型

//创建我们的用户Schema
const userSchema = new Schema({
    UserId:ObjectId,
    userName:{unique:true,type:String},
    password:String,
    createAt:{type:Date,default:Date.now()},
    lastLoginAt:{type:Date,default:Date.now()}
})

// 发布模型, User对应的是数据库里的users 这个表名字
// 大写的U变成了小写u，h后面又加了个s
mongoose.model('User', userSchema)
```

![avatar](/static/images/3.png)

## 解决 数据库名字和 我们程序里名字不一样的办法

![avatar](/static/images/4.png)

## 载入 Schema 和插入查出数据

- glob：node 的 glob 模块允许你使用 \* 等符号，来写一个 glob 规则，像在 shell 里一样，获取匹配对应规则文件。
- resolve: 将一系列路径或路径段解析为绝对路径。

```
npm install glob --save
```

在 init.js 引入

```
const glob = require('glob')
const {resolve} = require('path')

//把schema文件夹下所有的文件都引入的这里面， 利用通配符
exports.initSchemas = () =>{
    glob.sync(resolve(__dirname,'./schema/','**/*.js')).forEach(require)
}
```

## 操作数据库 在 index.js 中

```
const mongoose = require('mongoose')
const {connect , initSchemas} = require('./database/init.js')

//插入username
;(async () =>{
    await connect()
    initSchemas()
    const User = mongoose.model('User')
    let oneUser = new User({userName:'jspang',password:'123456'})
    oneUser.save().then(()=>{
        console.log('插入成功')
    })
})()
```

![avatar](/static/images/mongose.png)

# 加密

- 加密处理:比如我们使用的 MD5 加密或者 hash256 加密算法，暴力破解或者字典破解（彩虹表）都可以破解
- 加盐处理 :向我们的密码中加其他东西，

### bcrypt 的加密工具

利用淘宝源进行安装

```
npm install --save bcrypt --registry=https://registry.npm.taobao.org
```

在 schema\User.js 引入 bcrypt 的内容

```
const bcrypt = require('bcrypt')
let SALT_WORK_FACTOR =10 //加盐

userSchema.pre('save', function(next){
  //let user = this
  console.log(this)
  bcrypt.genSalt( SALT_WORK_FACTOR,(err,salt)=>{
      if(err) return next(err)
      bcrypt.hash(this.password,salt, (err,hash)=>{
          if(err) return next(err)
          this.password = hash
          next()
      })
  })
})
```

![avatar](/static/images/2.png)

# Koa2 的用户操作的路由模块化
下载
```
npm install koa-router --save
```
在 index.js 中引入

```
//引入路由插件
const Router = require('koa-router')
let user = require('./appApi/user')
//装载路由
let router = new Router();
router.use('/user', user.routes())
//加载路由中间件
app.use(router.routes())
app.use(router.allowedMethods()) //把所有的方法都装载进来
```

# 打通注册用户的前后端通讯

- 安装 koa-bodyparser 中间件 将字符串转化为对象
- 在 service/index.js 文件中注册和引入中间件

```
npm install --save koa-bodyparser

const bodyParser = require('koa-bodyparser')
app.use(bodyParser());
```

register.vue 头部引入 axios

```
import axios from 'axios'
import url from '@/serviceAPI.config.js'

//请求方法
axiosRegisterUser(){
        axios({
        url: url.registerUser,
        method: 'post',
        data:{
            username:this.username,
            password:this.password
        }
    })
    .then(response => {
        console.log(response)
    })
    .catch((error) => {
        console.log(error)
    })
}
```

修改 serviceAPI.config.js

```
const LOCALURL = "http://localhost:3000/"

const URL = {
    getShoppingMallInfo:BASEURL+'index',
    getGoodsInfo:BASEURL+'getGoodsInfo',
    registerUser:LOCALURL+'user/register',   //用户注册接口
}
module.exports = URL
```

# 解决跨域

安装 koa2-cors 中间件 要在 service/index.js

```
const cors = require('koa2-cors')
app.use(cors())
```

# 用户内容写入数据库

在 service/appApi/user.js 下引入 mongose

```
const mongoose = require('mongoose')

router.post('/register', async (ctx) => {

  //取得Model User是E:\A学习盘database\schema\User.js 文件夹的名字
  const User = mongoose.model('User')

  //把从前端接收的POST数据封装成一个新的user对象
  let newUser = new User(ctx.request.body)

  //用mongoose的save方法直接存储，然后判断是否成功，返回前端相应的结果
  await newUser.save().then(() => {
    //成功返回code=200，并返回成功信息
    ctx.body = {
      code: 200,
      message: '注册成功'
    }
  }).catch(error => {
    //失败返回code=500，并返回错误信息
    ctx.body = {
      code: 500,
      message: error
    }
  })
})
```

前端判断

```
 axiosRegisterUser() {
      axios({
        url: url.registerUser,
        method: 'post',
        data: {
          userName: this.username,
          password: this.password
        }
      })
        .then(response => { //成功判断
          if(response.data.code == 200){
            Toast.success(response.data.message)
          }else{
            console.log(response.data.message) //注册失败
            Toast.fail('注册失败')
          }
        })
        .catch((error) => { //是吧
          console.log(error)
        })
    }
```

# 注册防重复提交 在前台做的

绑定 loadding 属性。
<van-button type="primary" @click="axiosRegisterUser" :loading="openLoading" size="large">马上注册</van-button>
在代码中 点击按钮开始 this.openLoading =true,
其他地方都关闭 this.openLoading =false,（报错的地方，）

# 前端验证，

1. input 空值不能提交
2. 前端和后台都需要数据验证
   ![avatar](/static/images/5.png)

# 登录

## Shema 中的比对实例方法,

在 database\schema\User.js 里写 密码比对的方法

```
//密码比对的方法  methods是实例方法 必须用new 才能用
UserSchema.methods = {
  //_password 数据库密码 , password 当前密码
  comparePassword:(_password,password)=>{
      return new Promise((resolve,reject)=>{
          bcrypt.compare(_password,password,(err,isMatch)=>{
              if(!err) resolve(isMatch)
              else reject(err)
          })
      })
  }
}
```

## 进入 service/appApi/user.js，增加一个 login 路由

```
router.post('/login', async (ctx) => {
  //得到前端传递过来的数据
  let loginUser = ctx.request.body //前端传过来的对象
  console.log(loginUser)
  let userName = loginUser.userName
  let password = loginUser.password
  //引入User的model
  const User = mongoose.model('User')
  //查找名字
  await User.findOne({
    userName: userName
  }).exec().then(async (result) => {
    //判断用户名是否存在，如果存在就再比对密码
    if (result) {
      let newUser = new User() //因为是实例方法，所以要new出对象，才能调用
      await newUser.comparePassword(password, result.password) //comparePassword 再\database\schema\User.js 文件里的方法
        .then((isMatch) => {
          //返回比对结果
          ctx.body = {
            code: 200,
            message: isMatch
          }
        }).catch(error => {
          //出现异常，返回异常
          console.log(error)
          ctx.body = {
            code: 500,
            message: error
          }
        })
    } else {

    }
  }).catch(error => {
    console.log(error)
    ctx.body = {
      code: 500,
      message: error
    }
  })
})
```

## 前台配置接口

1.在 src/serviceAPI.config.js 下加入接口代码

```
const BASEURL = "https://www.easy-mock.com/mock/5c7006fba0b64b7d17824c17/SmileVue/"
const LOCALURL = "http://localhost:3000/"
const URL = {
    getShoppingMallInfo:BASEURL+'index',
  getGoodsInfo: BASEURL + 'getGoodsInfo',
  registerUser:LOCALURL+'user/register',   //用户注册接口
  login:LOCALURL+'user/login',   //用户登录接口
}
module.exports = URL
```

# 判断是否登录

利用 Promise 和 localStorage 存储

```
  axiosLoginUser() {
      //先把按钮进行loading状态，防止重复提交
      this.openLoading = true
      axios({
        url: url.login,
        method: 'post',
        data: {
          userName: this.username,
          password: this.password
        }
      })
        .then(response => {
          if (response.data.code == 200 && response.data.message) {
            //等待数据
            new Promise((resolve, reject) => {
              //存储
              localStorage.userInfo = { userName: this.username }
              //等半秒向下执行
              setTimeout(() => {
                resolve()
              }, 500)
            }).then(response => {
              //本地存储完了再页面跳转
              Toast.success('登录成功')
              this.$router.push('/')
            }).chart(error => {
              Toast.fail('登录失败')
              console.log(error);
            })
          } else {
            Toast.fail('登录失败')
            this.openLoading = false
          }
        })
        .catch((error) => {
          console.log(error)
          Toast.fail('登录失败')
          this.openLoading = false
        })
    },
```

读取是否登录

```
created(){
    if(localStorage.userInfo){
        Toast.success('您已经登录')
        this.$router.push('/')
    }
},

```

# 数据提纯

在 service 文件夹下，新建一个 fsJson.js 的文件使用 node 的 fs 模块

```
fs = require('fs')
fs.readFile('data_json/goods.json', 'utf8', function (err, data) {
  //转成对象格式
  let newData = JSON.parse(data)
  // 提取后的数组
  let i = 0 //看提纯后的数据有多少条
  let pushData = [] //存储到新的数组

  //map新数组
  newData.RECORDS.map(function (value, index) {
    //"IMAGE1" 不等于 null,时候才是有用的数据
    if (value.IMAGE1 != null) {
      i++
      console.log(value.NAME) //打印名字
      pushData.push(value)
    }
  })

  // 写到新的文件中
  fs.writeFile('./data_json/newGoods.json', JSON.stringify(pushData), function (err) {
    if (err) console.log('写文件操作失败');
    else console.log('写文件操作成功');
  });

})


//在下面路径执行 node fxjson.js
// vue-jsPangshangcheng\service> node fsJson.js

```

# 批量插入商品详情数据到 MongoDB 中

建立 servic/database/schema/Goods.js 文件

```
const mongoose = require('mongoose')    //引入Mongoose
const Schema = mongoose.Schema          //声明Schema
let ObjectId = Schema.Types.ObjectId    //声明Object类型
const goodsSchema = new Schema({
    ID:{unique:true,type:String},
    GOODS_SERIAL_NUMBER:String,
    SHOP_ID:String,
    SUB_ID:String,
    GOOD_TYPE:Number,
    STATE:Number,
    NAME:String,
    ORI_PRICE:Number,
    PRESENT_PRICE:Number,
    AMOUNT:Number,
    DETAIL:String,
    BRIEF:String,
    SALES_COUNT:Number,
    IMAGE1:String,
    IMAGE2:String,
    IMAGE3:String,
    IMAGE4:String,
    IMAGE5:String,
    ORIGIN_PLACE:String,
    GOOD_SCENT:String,
    CREATE_TIME:String,
    UPDATE_TIME:String,
    IS_RECOMMEND:Number,
    PICTURE_COMPERSS_PATH:String
},{
    collections:'Goods'
})
mongoose.model('Goods',goodsSchema)
```

新建一个 service/appApi/goods.js

```
const Koa = require('koa')
const app = new Koa()
const Router = require ('koa-router')
let router = new Router()
const mongoose = require('mongoose')
const fs = require('fs')
router.get('/insertAllGoodsInfo',async(ctx)=>{
     fs.readFile('./goods.json','utf8',(err,data)=>{
        data=JSON.parse(data)
        let saveCount=0
        const Goods = mongoose.model('Goods')
        data.map((value,index)=>{
            console.log(value)
            let newGoods = new Goods(value)
            newGoods.save().then(()=>{
                saveCount++
                console.log('成功'+saveCount)
            }).catch(error=>{
                 console.log('失败：'+error)
            })
        })
    })
    ctx.body="开始导入数据"
})
module.exports=router;
```

.把路由加入到 index.js 里

```
let goods = require('./appApi/goods.js')
router.use('/goods',goods.routes())
```

# 商品大类的 Shema 建立和导入数据库

在 database\schema\Category.js 写数据库表名配置

```
const mongoose = require('mongoose')    //引入Mongoose
const Schema = mongoose.Schema          //声明Schema
const categorySchema = new Schema({
    ID:{unique:true,type:String},
    MALL_CATEGORY_NAME:{type:String},
    IMAGE:{type:String},
    TYPE:{type:Number},
    SORT:{type:Number},
    COMMENTS:{type:String}
})
mongoose.model('Category',categorySchema)
```

# AIP 配置

service/appApi/category.js 文件里增加一个路由配置

```
router.get('/insertAllCategory',async(ctx)=>{
    fs.readFile('./data_json/category_sub.json','utf8',(err,data)=>{
        data = JSON.parse(data)
        let saveCount = 0
        const CategorySub = mongoose.model('CategorySub')
        data.RECORDS.map((value,index)=>{
            console.log(value)
            let newCategorySub = new CategorySub(value)
            newCategorySub.save().then(()=>{
                saveCount++
                console.log('成功插入'+saveCount)
            }).catch(error=>{
                console.log('插入失败:'+error)
            })
        })
    })
    ctx.body="开始导入数据"
})
```

把路由加入到 index.js 里

```
let category = require('./appApi/category.js')
router.use('/category',category.routes())
```

启动项目在 url 执行 http://localhost:3000/category/insertAllCategory

# 详情页面 调用接口

写接口 service\appApi\goods.js

```
// 获取商品详情的接口 需要传递数据所以用post
router.post('/getDetailGoodsInfo', async (ctx) => {
  //通过商品的id 获取商品详情 ，查找详情
  let goodsId = ctx.request.body.goodsId
  const Goods = mongoose.model('Goods')
  //通过id查询
  await Goods.findOne({ ID: goodsId }).exec()
    .then(async (result) => {
      ctx.body={code:200,message:result}
    }).catch(error => {
      console.log(error);
      ctx.body={code:500,message:error}
    })
})
```

数据库配置 \database\schema\Goods.js

```
const mongoose = require('mongoose') //引入Mongoose
const Schema = mongoose.Schema //声明Schema
let ObjectId = Schema.Types.ObjectId //声明Object类型
const goodsSchema = new Schema({
  ID: {
    unique: true,
    type: String
  },
  GOODS_SERIAL_NUMBER: String,
  SHOP_ID: String,
  SUB_ID: String,
  GOOD_TYPE: Number,
  STATE: Number,
  NAME: String,
  ORI_PRICE: Number,
  PRESENT_PRICE: Number,
  AMOUNT: Number,
  DETAIL: String,
  BRIEF: String,
  SALES_COUNT: Number,
  IMAGE1: String,
  IMAGE2: String,
  IMAGE3: String,
  IMAGE4: String,
  IMAGE5: String,
  ORIGIN_PLACE: String,
  GOOD_SCENT: String,
  CREATE_TIME: String,
  UPDATE_TIME: String,
  IS_RECOMMEND: Number,
  PICTURE_COMPERSS_PATH: String
}, { //表名在数据库不会变
  collections: 'Goods'
})
mongoose.model('Goods', goodsSchema)

```

路径配置 src\serviceAPI.config.js

```
const LOCALURL = "http://localhost:3000/"
const URL = {
  getDetailGoodsInfo:LOCALURL+'goods/getDetailGoodsInfo',   //获取商品详情接口
}
module.exports = URL
```

页面调用接口

```
import axios from 'axios'
export default {
  data() {
    return {
      goodsId: '0032862950ca44d397e58a6fb10a3e38'
    }
  },
  created() {
    this.getInfo()
  },
  methods: {
    getInfo() {
      axios({
        url: url.getDetailGoodsInfo,
        method: 'post',
        data: {
          goodsId: this.goodsId //传递的参数
        }
      })
        .then(response => {
          console.log(response) //获取结果
        })
        .catch(error => {
          console.log(error)
        })
    }
  },
}
```

# 点击当前产品获取当前 id，传给后台

跳转页面需要带参数 pages\ShoppingMall.vue 页面
:goodsId="item.goodsId"

```
 <van-col span="12" v-for="(item,index) in hotGoods" :key="index">
  <goods-info :goodsId="item.goodsId" :goodsImage="item.image" :goodsName="item.name" :goodsPrice="item.price"></goods-info>
</van-col>
```

到 components\component\goodsInfoComponent.vue 页面接收

```
<template>
  <div class="goods-info" @click="goGoodsPage()">
    <div class="goods-price">￥{{goodsPrice | moneyFilter }}</div>
  </div>
</template>
<script>
import { toMoney } from '@/filter/moneyFilter.js'
export default {
  props: ['goodsImage', 'goodsName', 'goodsPrice','goodsId'],
  filters: {
    moneyFilter(money) {
      return toMoney(money)
    }
  },
  methods:{
    // 点击页面跳转 传递参数
    goGoodsPage(){
      this.$router.push({name:'goods',query:{goodsId:this.goodsId}})
    }
  }
}
```

详情页接收参数 并发起调用

```
export default {
  data() {
    return {
      goodsId: ''
    }
  },
  created() {
    //获取 src\components\component\goodsInfoComponent.vue 穿过来的参数
    this.goodsId = this.$route.query.goodsId
    console.log(this.goodsId)
    this.getInfo()
  },
  methods: {
    //接收参数后发起请求
    getInfo() {
      axios({
        url: url.getDetailGoodsInfo,
        method: 'post',
        data: {
          goodsId: this.goodsId //传递的参数
        }
      })
        .then(response => {
          console.log(response)
        })
        .catch(error => {
          console.log(error)
        })
    }
  },
}
```

# 按住屏幕滑动切换(swipeable), 和吸顶效果（sticky）

```
<van-tabs  swipeable sticky>
    <van-tab title="商品详情">
        <div class="detail" v-html="goodsInfo.DETAIL">
        </div>
    </van-tab>
    <van-tab title="评价">
        正在制作中
    </van-tab>
</van-tabs>
```

# 二级联动效果分类页面的读取， 获取大类和小类

读取大类接口 是 get 请求

```
router.get('/getCategoryList', async (ctx) => {
  try {
    //database\schema\Category.js 定义的 Category
    const Category = mongoose.model('Category')
    let result = await Category.find().exec()
    //返回给前端
    ctx.body = {
      code: 200,
      message: result
    }

  } catch (error) {
    ctx.body = {
      code: 500,
      message: error
    }
  }
})
```

![avatar](\static\images\6.png)

### 获取小类信息，通过大类的 id 获取小类 所以小类是 post

```
router.post('/getCategorySubList', async (ctx) => {
  try {
    let categoryId = ctx.request.body.categoryId
    const CategorySub = mongoose.model('CategorySub')
    let result = await CategorySub.find({
      MALL_CATEGORY_ID: categoryId
    }).exec()
    ctx.body = {
      code: 200,
      message: result
    }
  } catch (err) {
    ctx.body = {
      code: 500,
      message: err
    }
  }
})
```

# 前端设置大类和小类接口

```
const LOCALURL = "http://localhost:3000/"
const URL = {
  getCategoryList:LOCALURL+'goods/getCategoryList',   //获取大类商品
  getCategorySubList:LOCALURL+'goods/getCategorySubList',   //获取小类商品
}
module.exports = URL
```

# 前端绑定接口

```
export default {
  data() {
    return {
      category: [], //大类存储数据
      categorySub: [],  //小类的内容
      categoryIndex: 0,  //样式设置
      active: 0,  //第一个被激活
    }
  },
  created() {
    this.getCategory()
  },
  mounted() { //动态设置左侧高度
    let winHeight = document.documentElement.clientHeight
    document.getElementById("leftNav").style.height = winHeight - 46 + 'px'
  },
  methods: {
    //获取商品大类
    getCategory() {
      axios({
        url: url.getCategoryList,
        method: 'get'
      }).then(response => {
        if (response.data.code == 200 && response.data.message) {
          this.category = response.data.message
          console.log(this.category);
          //当我们获得大类的时候，调用一下小类,获得的是大类第一个值得id
          this.getCategorySubByCategoryId(this.category[0].ID)
        } else {
          Toast('数据获取失败')
        }
      }).catch(error => {
        console.log(error)
      })
    },
    //根据大类获取小类内容
    getCategorySubByCategoryId(categoryId) {
      axios({
        url: url.getCategorySubList,
        method: 'post',
        data: { categoryId: categoryId }
      })
        .then(response => {
          if (response.data.code == 200 && response.data.message) {
            this.categorySub = response.data.message
            this.active = 0 //切换数据默认样式归0
          } else {
            Toast('服务器错误，数据取得失败')
          }
        })
        .catch(error => {
          console.log(error)
        })
    },
    //点击大类的方法
    clickCategory(index, categoryId) {
      this.categoryIndex = index;
      this.getCategorySubByCategoryId(categoryId)
    }
  }
}
```

# 向下滑动刷新数据 向上滑动加载数据

### 引入 Vant 中的 PullRefresh 组件

引入 pullRefresh 组件就可以实现下拉刷新效果，我们先在 src/main.js 中引入一下

```
import {PullRefresh} from 'vant'
Vue.use(PullRefresh)
```

### 设置变量

```
data() {
    return {
        loading:false,   //上拉加载使用
        finished:false,  //上拉加载是否没有了？
        isRefresh:false, //下拉加载
    }
}
```

### 上拉加载 js 方法 和 下拉刷新方法

```
 // 上拉加载数据
    onLoad() {
      setTimeout(() => {
        for (let i = 0; i < 10; i++) {
          this.list.push(this.list.length + 1)
        }
        console.log(this.list);
        this.loading = false;
        //不能一直有这种加载的效果，达到40条就关闭，没有数据了
        if (this.list.length >= 40) {
          this.finished = true;
        }
      }, 500)
    },
    // 下拉刷新时间，需要延时
    onRefresh() {
      setTimeout(() => {
        this.isRefresh = false;
        this.finished = false; //设置成 false才能从新加载
        this.list = []; //情况数据
        this.onLoad() //再调用加载数据
      }, 500);
    }
```

### html 代码结果

```
<div id="list-div">
    <van-pull-refresh v-model="isRefresh" @refresh="onRefresh">
        <van-list
            v-model="loading"
            :finished="finished"
            @load="onLoad"
            >
            <div class="list-item" v-for="item in list" :key="item">
                {{item}}
            </div>
        </van-list>
    </van-pull-refresh>
</div>
```

# 完整的数据 加载

![avatar](\static\images\7.png)

### 前端

```
export default {
  data() {
    return {
      category: [], //大类存储数据
      categorySub: [],  //小类的内容
      categoryIndex: 0,  //样式设置
      active: 0,  //第一个被激活
      list: [], //存储加载的内容
      loading: false,   //上拉加载使用
      finished: false,  //上拉加载是否没有数据了
      isRefresh: false, //下拉加载
      page: 1,  //商品列表页数
      goodList: [], // 商品列表信息
      categorySubId: '', //获取商品子类id


    }
  },
  created() {
    this.getCategory()
  },
  mounted() {
    let winHeight = document.documentElement.clientHeight
    document.getElementById("leftNav").style.height = winHeight - 46 + 'px'
    document.getElementById("list-div").style.height = winHeight - 90 + 'px'
  },
  methods: {
    //（1）--------------左侧列表 页面加载获取商品大类列表
    getCategory() {
      axios({
        url: url.getCategoryList,
        method: 'get'
      }).then(response => {
        if (response.data.code == 200 && response.data.message) {
          this.category = response.data.message
          console.log(this.category);
          //当我们获得大类的时候，调用一下小类,获得的是大类第一个值得id
          this.getCategorySubByCategoryId(this.category[0].ID)
        } else {
          Toast('数据获取失败')
        }
      }).catch(error => {
        console.log(error)
      })
    },
    //（1.2）-----------------点击左侧列表 获取头部子类列表
    clickCategory(index, categoryId) {
      this.categoryIndex = index;
      //点击大类的时候也要把分页设置成1，
      this.page = 1
      this.finished = false //到底效果清空
      this.goodList = [] //小类列表清空
      this.getCategorySubByCategoryId(categoryId)
    },
    //（2）******************* 通过id 获取头部子类列表
    getCategorySubByCategoryId(categoryId) {
      axios({
        url: url.getCategorySubList,
        method: 'post',
        data: { categoryId: categoryId }
      })
        .then(response => {
          if (response.data.code == 200 && response.data.message) {
            this.categorySub = response.data.message
            this.active = 0 //切换数据默认样式归0
            this.categorySubId = this.categorySub[0].ID
            this.onLoad()
          } else {
            Toast('服务器错误，数据取得失败')
          }
        })
        .catch(error => {
          console.log(error)
        })
    },
    // (2.1) *******************点击子类的列表，获取详细内容
    onClickCategorySub(index, title) {
      this.categorySubId = this.categorySub[index].ID;
      console.log(this.categorySubId)
      this.goodList = []
      this.finished = false //到底部了
      this.page = 1  //从第一页开始
      this.onLoad() //调用
    },
    // （3）++++++++++++++++++通过id 调用详情页面的方法
    onLoad() {
      setTimeout(() => {
        //刚进入页面是没有 categorySubId 我们需要进行判断 ,如果没有进从子类数据中的第一个的id
        this.categorySubId = this.categorySubId ? this.categorySubId : this.categorySub[0].ID
        this.getGoodList()
      }, 500)

    },
    // (4)  +++++++++++++ 详情页面的方法
    getGoodList() {
      axios({
        url: url.getGoodsListByCategorySubID,
        method: 'post',
        data: {
          categorySubId: this.categorySubId,
          page: this.page
        }
      }).then(response => {
        console.log(response);
        if (response.data.code == 200 && response.data.message.length) {
          //每次调用都会增加到下一页
          this.page++
          //将两次请求的数据添加到一个数组中
          this.goodList = this.goodList.concat(response.data.message)
        } else {
          this.finished = true //已经没有数据了
        }
        this.loading = false; //请求完毕
      }).catch(error => {
        console.log(error);
      })
    },

    // @@@@@@@   详情页面 下拉刷新 事件 ，需要延时
    onRefresh() {
      setTimeout(() => {
        this.isRefresh = false;
        this.finished = false; //设置成 false才能从新加载
        this.goodList = [];
        this.page = 1 //情况数据
        this.onLoad() //再调用加载数据
      }, 500);
    },
  }
}
```

### 接口配置

在 src\serviceAPI.config.js 配置

```
  getDetailGoodsInfo:LOCALURL+'goods/getDetailGoodsInfo',   //获取商品详情接口
  getCategoryList:LOCALURL+'goods/getCategoryList',   //获取大类商品列表
  getCategorySubList: LOCALURL + 'goods/getCategorySubList',   //获取小类商品列表
  getGoodsListByCategorySubID:LOCALURL+'goods/getGoodsListByCategorySubID',   //得到小类商品信息 和分页
```

### 后台

```
const Koa = require('koa')
const app = new Koa()

const Router = require('koa-router')
let router = new Router()

const mongoose = require('mongoose')
const fs = require('fs')

//获取商品接口
router.get('/insertAllGoodsInfo', async (ctx) => {
  fs.readFile('./data_json/newGoods.json', 'utf8', (err, data) => {
    data = JSON.parse(data)
    let saveCount = 0
    const Goods = mongoose.model('Goods')
    //插入数据库
    data.map((value, index) => {
      console.log(value)
      let newGoods = new Goods(value)
      newGoods.save().then(() => {
        saveCount++
        console.log('成功' + saveCount)
      }).catch(error => {
        console.log('失败：' + error)
      })
    })
  })
  ctx.body = "开始导入数据"
})

// 获取商品详情的接口 需要传递数据所以用post
router.post('/getDetailGoodsInfo', async (ctx) => {
  // //通过商品的id 获取商品详情 ，查找详情
  // let goodsId = ctx.request.body.goodsId
  // const Goods = mongoose.model('Goods')
  // //通过id查询
  // await Goods.findOne({ ID: goodsId }).exec()
  //   .then(async (result) => {
  //     ctx.body={code:200,message:result}
  //   }).catch(error => {
  //     console.log(error);
  //     ctx.body={code:500,message:error}
  //   })

  //第二种写法
  try {
    let goodsId = ctx.request.body.goodsId
    const Goods = mongoose.model('Goods')
    let result = await Goods.findOne({
      ID: goodsId
    }).exec()
    ctx.body = {
      code: 200,
      message: result
    }
  } catch (err) {
    ctx.body = {
      code: 500,
      message: err
    }
  }
})


//读取大类接口
router.get('/getCategoryList', async (ctx) => {
  try {
    //database\schema\Category.js 定义的 Category
    const Category = mongoose.model('Category')
    let result = await Category.find().exec()
    //返回给前端
    ctx.body = {
      code: 200,
      message: result
    }

  } catch (error) {
    ctx.body = {
      code: 500,
      message: error
    }
  }
})

// 获取小类信息，通过大类获取小类
router.post('/getCategorySubList', async (ctx) => {
  try {
    let categoryId = ctx.request.body.categoryId
    const CategorySub = mongoose.model('CategorySub')
    let result = await CategorySub.find({
      MALL_CATEGORY_ID: categoryId
    }).exec()
    ctx.body = {
      code: 200,
      message: result
    }
  } catch (err) {
    ctx.body = {
      code: 500,
      message: err
    }
  }
})

//根据类别获取商品列表
router.post('/getGoodsListByCategorySubID', async (ctx) => {
  try {
    let categorySubId = ctx.request.body.categorySubId //子类别id
    let page = ctx.request.body.page
    let num = 10 //每页显示数量
    let start = (page - 1) * num //数据从第几个开始 传过来的是1 （1-1）*mum  就是0

    const Goods = mongoose.model('Goods')
   //数据库查找
    let result = await Goods.find({
        SUB_ID: categorySubId  //SUB_ID 是数据库字段
      }).skip(start).limit(num).exec() //skip() 跳过   .limit() 限制每页显示的数量
    ctx.body = {
      code: 200,
      message: result
    }
  } catch (err) {
    ctx.body = {
      code: 500,
      message: err
    }
  }

})

module.exports = router;

```

# 增加默认图片

设置默认图片 pages\CategoryList.vue

```
  data() {
    return {
      errorImg: 'this.src="' + require('&/images/default.png') + '"',
    }
  },
```

绑定内容

```
<div class="list-item-img">
    <img :src="item.IMAGE1" width="100%" :onerror="errorImg"/>
</div>
```

# 什么时候用 query 什么时候用 params

### params 传参，路径不能使用 path，只能使用 name，不然取不到传的数据。

```
设置值
this.$router.push({name:'Goods',params:{goodsId:id}})

获取值
this.$route.params.goodsId
```

### query 传参，用的是 path，而不是 name,否则也会出错。

```
设置
this.$router.push({path:'/Goods',query:{goodsId:id}})

获取
this.$route.query.goodsId
```

# 添加购物车

- 查看本地是否有数据
- 本地存储
- 判断不能重复

### 在 pages\Goods.vue 的 addGoodsToCart（）增加购物方法

```
  data() {
    return {
      goodsId: '',
      goodsInfo: {},   //存储商品详细数据
    }
  },
  methods: {
    //增加商品到购物车
    addGoodsToCart() {
      //查看本地localStorage 有没有数据,有就赋值，没有就存储
      let cartInfo = localStorage.cartInfo ? JSON.parse(localStorage.cartInfo) : []

      //判断当前数组里是否存在，如果存在就不添加， 如果没有返回undeifnd，如果有返回第一个查找到的数据
      let isHaveGoods = cartInfo.find(cart => cart.goodsId == this.goodsId)

      if (!isHaveGoods) {
        //没有商品直接添加到数组中
        //重新组成添加到购物车的信息
        let newGoodsInfo = {
          goodsId: this.goodsInfo.ID,
          Name: this.goodsInfo.Name,
          price: this.goodsInfo.PRESENT_PRICE,
          image: this.goodsInfo.IMAGE1,
          count: 1 //商品的个数
        }
        cartInfo.push(newGoodsInfo) //添加到购物车
        localStorage.cartInfo = JSON.stringify(cartInfo) //操作本地数据
        Toast.success('添加成功')
      }else{
        Toast.success('已有此商品')
      }
        this.$router.push({name:'cart'})  //进行跳转
    }
  },
}
```

### html 页面绑定

```
<van-button size="large" type="primary" @click="addGoodsToCart">加入购物车</van-button>
```

### cart 页面接收传过来的内容

在\pages\Cart.vue

```
  data() {
    return {
      cartInfo: [], //购物车数据
      isEmpty: false //查看购物车是否为空

    }
  },
  created() {
    this.getCartInfo()
  },
  methods: {
    //获取传过来的数据
    getCartInfo() {
      //判断是否有这个信息，
      if (localStorage.cartInfo) {
        this.cartInfo = JSON.parse(localStorage.cartInfo)
      }
      console.log(JSON.stringify(this.cartInfo));
      //判断是否为空
      this.isEmpty = this.cartInfo.length > 0 ? true : false
    },
```

### html 绑定

```
<div class="cart-list">
    <div class="pang-row" v-for="(item,index) in cartInfo" :key="index">
        <div class="pang-img"><img :src="item.image" width="100%" /></div>
        <div class="pang-text">
            <div class="pang-goods-name">{{item.Name}}</div>
                <div class="pang-control">
                <van-stepper v-model="item.count" />
            </div>
        </div>
        <div class="pang-goods-price">￥{{item.price}}</div>
    </div>
</div>
```

# 购物车计算商品

在\components\pages\Cart.vue

```
 //计算属性
  computed: {
    totalMoney() {
      let allMoney = 0
      //每一项的单价乘以总价格，监控数据变化
      this.cartInfo.forEach((item, index) => {
        allMoney += item.price * item.count
      });
      // 刷新页面 内容保存
      localStorage.cartInfo = JSON.stringify(this.cartInfo)
      return allMoney
    }
  },
```

1. 安装 koa 在 service\index.js 写 koa 的配置
2. 安装 mongoDB 在/service/database/init.js 写 mongoDB 的配置
3. 下载界面化工具 robo 3t 的下载
4. Schema 字段格式配置 在 service\database\schema\User.js 写数据库字段格式配置
5. glob 在/service/database/init.js 读取 所有 schema 文件夹下的内容
6. 写入数据量内容 在 service\index.js 写入内容
7. 启动顺序，先启动数据库 cmd 后执行 mongod 再执行 node index.js
8. bcrypt 加盐加密处理
9. 用户操作路由模块 koa-router
10. 打通注册用户的前后端通讯 koa-bodyparser 将传入的对象转为字符串
11. koa 解决跨域安装 koa2-cors 中间件
12. 防重复提交
13. 登录效果，需要解密 bcrypt.compare
14. 前端交互效果和登录内容储存,登录一次只要没有退出就不让继续登录 localStorage
15. created 中验证 页面是否已经登录过如果登录，就让其跳到当前页
16. 数据提纯筛选数据
17. 从 JSON 格式导入到 MongoDB 数据库中
18. 解决图片有空隙问题 .detail{ font-size:0px;} 图片之间的空格影响的
19. 标签转化 v-html="goodsInfo.DETAIL"
20. 布局 父页面 .goods-bottom{display: flex; flex-direction: row; flex-flow:nowrap;} 子页面.goods-bottom > div{flex:1; padding:5px;}
21. 滑动效果和吸顶效果
22. get 和 post 的请求
23. 读取 大类商品 和小类的区别 比如 （水果：包括苹果，香蕉）水果是大类，苹果是小类 ,也就是商品分类的联动效果
24. 声明周期页面开始加载的时候(mounted)创建 dom 元素
25. 切换数据默认样式归 0 有二级菜单的情况下
26. 上拉加载效果的实现的方法
27. 列表三级联动效果
28. 解决默认图片问题
29. 接收参数什么时候用 query 什么时候用 params，

# 页面的流程图，从数据库到前端

1. 配置字段 E:\A 学习盘 schema\Category.js
2. 设置接口返回前端数据 appApi\goods.js
3. 前端配置接口 src\serviceAPI.config.js
4. 写页面 src\components\pages\Goods.vue
5. 配置路由 src\router\index.js
6. 在 Goods.vue 调用接口 绑定数据
